연산자와 피연산자 연산자의 종류


연산자 : 연산을 수행하는 기호,,
피연산자 : 연산자의 연산 수행 대상

[ x+3 ] -> 피연산자 + 연산자 + 피연산자
// 모든 연산자는 연산괄과를 반환한다.!!

연산자의 종류
1. 산술 연산자 +,0,,/,%,<<,>>
2. 비교 연산자 >, <, >=,<=, ==, !=
3. 논리 연산자 &&, || !, &
4. 대입 연산자 =
5. 기타          (type) ?: instanceof

연산자의 우선순위, 연산자의 결합규칙


연산자의 우선순위
-> 연산자가 둘 이상 있을때, 
    어떤 연산을 먼저 수행할지를 {자동결정} 하는 것.

-> 단항, 산술, 비교, 논리, 삼항, 대입,,


연산자의 결합규칙
-> 우선순위가 같은 연산자가 있을 때, 어떤 것을 먼저 할까?
// 대입연산자, 단항연산자는 오른쪽에서 왼쪽으로 연산 실행
// 대입과 단항 연산자를 제외하면, 왼쪽에서 오른쪽으로 연산 실행
--> 모든 연산자는 연산 결과를 반환한다.!!

1. 산술 > 비교 > 논리 > 대입
2. 단항 > 이항 > 삼항
3. 단항과 대입을 제외한 모든 연산은 왼쪽에서 오른쪽으로 연산된다.


증감연산자 와 부호연산자
++i; -> 전위형   ,   i++; -> 후위형

증감 연산자
++i;   ,   j=i; 를 단축한 것이 j=++i;

j = i; 를 열어놓은 것이 j=i;   ,   i++;


부호연산자
'-'는 피연산자의 부호를 반대로 변경
'+'는 아무런 일도 하지 않는다.  //실제로 사용하지 않는다.



형변환 연산자

형변환이란?
-> 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
형변환하는 방법 => (타입)피연산자

만일 변수 타입과 값이 서로 같지 않다면,
인위적으로 변수 타입과 변수의 값을 일치하면 에러가 나오지 않는다.
// 그것을 용어로 자동 형변환이라고 한다.
   그리고 컴파일러가 자동으로 형변환 시키는 것이다.

// plus로 변수 타입이 크고 값이 작으면 
   생략이 가능한데, 그것을 자동 형변환 이라고 한다.

/* c가 44가 나오는 이유는 '자동 형변환'으로 보면 알 수 있다.
   변수타입이 값보다 크면 값에 타입을 지정하지 않아도(생략가능)
   변수타입이 값보다 작다면 값의 오류가 일어나 에러를 발생        */

   1         2         3        4         8         16
byte -> short -> int -> long -> float -> double
                       ^
                        |
           char  -----



사칙 연산자, 산술변환

== 산술변환이란?
-> "연산 전에 피연산자의 {타입을 일치}시키는 것"
// 계산할때, 자동으로 바꾸는 것..
// 타입을 일치시켜야 계산이 가능하다 -> 이것을 산수 변환

1. 두 피연산자나의 타입을 같게 일치시킨다
   (보다 큰 타입으로 일피)

  8       4             8        8                8
long + int      -> long + long        -> long
float + int      -> float + float        -> float
double + float -> double + double -> double
// 범위가 큰 것부터 선택을 하장~!!! 그리고 그렇게 됨..

2. 피연산자의 타입이 int보다 작은 타입이면 int로 변화된다.

  1        2         4     4       4
byte + short -> int + int -> int
char + short -> int + int -> int
EX> '2'-'0' = 50-48 = 2



반올림 - Math.round( )
-> t실수를 소수점 첫 째자리에서 반올림한 정수를 반환

나머지 연산자 %
-> 오른쪽 파연산자로 나누고 남은 나머지를 반환
-> 나누는 피연산자는 0이 아닌 정수만 허용 
    (부호는 무시됨)
Ex> ("몫 : %d , 나머지: %d.%n", x / y, x % +y); 
      ("몫 : %d , 나머지: %d.%n", x / y, x % -y); 

비교 연산자
-> 두 피연자를 비교해서 true(참) OR false(거짓)을 반환
1. >,    2. <,    3. >=,    4. <=,    5. ==,    6. !==

문자열의 비교
-> 문자열 비교에는 ==대신 equals()를 사용해야 한다.

논리 연산자 && ||
-> 조건식을 연결할 때 사용하느 연산자
(AND결합) , (OR결합)

Ex> 1. x는 10보다 크고, 20보다 작다.
      2. i는 2의 배수 또는 3의 배수이다.
      3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
      4. 문자 ch는 숫자('0'~'9')이다.
      5. 문자 ch는 대문자 OR 소문자이다.

논리 부정 연산자
-> true를 false로, false는 true로 바꾼다.
// ! = 단항연산자 --> 오른쪽에서 왼쪽
   boolean b = true;
   !!b => !(!true) -> !false => true

Ex> 1.  !('a' <= ch && ch <='z') 
       // 논리 부정 연산자를 사용하면 가독성이 
           높아지는 효과를 불려올 수 있습니다!!

조건연산자 ? :
-> 조건식의 결과에 따라 연산결과를 달리한다.
   { 조건식 ? 식1 : 식2 }
// [식1] 은 참(true)  ,   [식2] 은 거짓(false) 
Ex> result = (x > y)_조건식 ? x_참(true) : y_거짓(false) ;

대입 연산자
-> 오른쪽 피 연산자를 왼쪽 피연산자에 저장 후
     저장된 값을 반환

Ex > System.out.println(x=3);
       System.out.println(3);
// " 모든 연산자는 결과 값을 반환 " //

lvalue - 대입 연산자의 왼쪽 피연산자
rvalue - 대입 연산자의 오른쪽 연산자

 x(left value [ lvalue ] )  =  3(right value [ rvalue ] )
1. lvaule = 저장공간이어야 함  !![변수 OR 배열]!!

Ex> int i = 0;
      3 = i + 3;              //error
      i + 3 = i;               //error

     final int MAX = 2;    //final 는 상수
     MAX = 10;             //error final는 새로운 값 저장 불가능

복함 대입 연산자
-> 대입 연산자와 다른 연산자를 하나로 축약
{ i +=3; }         ==  { i = i+3; }
{ i *= 10 + j; }  ==  { i = i * ( 10+j ); }





























































