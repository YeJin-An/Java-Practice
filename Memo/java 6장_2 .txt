객체지향 언어

80년대 초 소프트웨어의 의기 - 빠른 변화를 못쫒아감
해결책으로 객체지향 언어를 도입 (절차적->객체지향)

-> 코드의 재사용성
-> 유지보수가 용이
-> 중복 코드 제거

// 객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)


OOP[object-orianted progeamming]
1. 캡슐화   2. 상속   3. 추상화   4.다형성



{클래스와 객체 {객체의 구성요소-속성과 기능} }

클래스와 객체
클래스의 정의 -> 클래스란 객체를 정의해 놓은 것
클래스의 용도 -> 클래스는 객체를 생성하는데 사용

객체의 정의 -> 실제로 존재하는 것. 사물 or 개념
객체의 용도 -> 객체가 가지고 있는 기능과 속성에 따라 
                    다름

객체의 구성요소_[속성과 기능]
1. 실제세계에서 분석&관찰을 했다.
2. HW -> SW화 하는 것이 목표였다.
3. SW프로그램은 코드작성을 의미한다??
// 객체 = 속성(변수) + 기능(메서드)


객체와 인스턴스
객체 -> 모든 인스턴스를 대표하는 일반적 용어
인스턴스 -> 특정 클래스루부터 생성된 객체
                 Ex Tv인스턴스
// 객체와 인스턴스는 거의 같은 말이다.

{클래스}가 {인스턴스화}가 되면 {인스턴스(객체)}가 된다
클래스 -> 설계도  , 인스턴스화 -> 재품생성 ,  
                          인스턴스 -> 제품


{정리} 클래스와 객체
Q. 클래스가 왜 필요한가? A. 객체를 생성하기 위해
Q. 객체가 왜 필요한가?   A. 객체를 사용하기 위해
Q. 객체를 사용한다는 것은? 
                A. 객체가 가진 속성과 기능을 사용하려고


{ 한 파일에 여러 클래스 작성하기 }
1. public class가 있는 경우,
  소스파일의 이름은 반드시 public class의 이름과 일치
2. public class가 하나도 없는 경우, 
  소스파일의 이름은 파일이름과 같아도 달라도 됨.


{ 객체의 생성과 사용 }
1. 객체의 생성
-> Tv t = new Tv( );
// t는 참조변수(리모콘) , 객체는 new Tv();
   1) 참조변수  2) 객체  3) 연결

2. 객체의 사용
t.chammel = 7;    t.channelDown();
System.out.println("현재 채널은 "+t.channel+" 입니다.");
//{변수사용} 과 {메서드사용(메서드호출)}

Ex> t2 = t1; 
--> 리모콘과 객체의 연결이 끊어짐.
--> 다른 객체의 연결이 리모콘++ 가 됨.
// 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우
   ->     가능
// 여러 인스턴스를 하나의 참조변수가 가리키는 경우
   -> 불 가능



{ 객체 배열 }
객체 배열 == 참조변수 배열
Tv tv1, tv2, tv3;  --> Tv[] tvArr = new Tv[3];
                           Tv타입 참조변수 *3

tvArr  ----> tvArr[0], tvArr[1], tvArr[2]

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

Tv[] tvArr = { new Tv(), newTv(), new Tv() };


{클래스의 정의(1)}
클래스 ---> 1)설계도, 2)데이터+함수, 3)사용자정의함수
클래스 == 데이터 + 함수

1. 변수    -> 하나의 데이터를저장할 수 있는 공간
2. 배열    -> 같은 종류의 여러 데이터를 
                 하나로 저장할 수 있는 공간
3. 구조체 -> 서로 관련된 여러 데이터(종류 관계x)를 
                 하나로 저장할 수 있는 공간
                 // 서로 다른 타입이 ok!
4. 클래스 -> 데이터와 함수의 결함 (구조체 + 함수())
  = 명령문 묶음(작업, 계산)


{클래스의 정의(2)}
사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.
                         /원하는 타입 -> 클래스

class Time {
    int hour;
    int minute;
    int second;
}

Time t = new Time();
Time tn = new Time();
Time[] t = new Time[3];


{ 선언 위치에 따른 변수의 종류 }
1. 클래스 영역 --> iv (인스턴스 변수), 
                        cv (클래스변수, static변수, 공유변수)

2. 메서드 영역 --> lv (지역변수)


클래스 영역 -> 선언문만 가능
---> 변수선언
---> 메서드 선언(메소드 정의)

변수의 종류           선언  위치         생성시기
-----------------------------------------------------------------------------
클래스 변수             클래스           클래스가 메모리에 올라갈 때
인스턴스 변수          영   역           인스턴스가 생성되었을 때

지역변수              클래스 영역       변수 선언문이 수행되었을 때
                         이외의 영역


// 다시 객체 정리 -> iv를 묶어 놓은 것
// 메모리에 올린다 -> ssd와 cpu의 속도차이로 RAM이 필요
                             "로딩이란" 이름으로 RAM에 있는 것을 의미
CPU는 RAM하고만 논다 -> {로딩} AND {세이브}


//   클래스 변수 -> 객체 생성 (X) -> 아무때나 사용 가능.
   인스턴스 변수 -> 객체 생성(O) -> 객체 생성해야 사용 가능.


{ 클래스 변수 AND 인스턴스 변수 차이점 }
   클래스 변수 -> 공통속성  -> static
인스턴스 변수 -> 개별 속성 -> static X

Card c = new Card();  // 객체생성
c. kind = "HEART";     // 객체사용_iv
Card.width = 200      // 객체사용_cv


{ 메서드란? 메서드의 선언부와 구현부 }
메서드란?
1. 문장들을 묶어 놓은 것. { 배열초기화 AND 배열 출력 }
 
public class Hello {
static void printArr(int[] numArr){ } //코드 중복을 위한 것
public static void main(String arg[]){ 
        for(int i =0; i<10; i++){numArr[i] = (int)(Math.random()*10)}
        // 배열 초기화
        printArr(numArr) //메서드 호출(사용)
    }
}


// 다시 정리
메서드란?
1. 문자들 묶은 것
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)


메서드는 반드시 클래스안에 있어야 한다.
허나 함수는 클래스에 독립적이다.
// 근본적으로는 클라스와 함수는 똑같다.!

black box 란 -> 함수가 동작하는 로직같은 걸 말한다

// 다시정리
메서드란? _장점
1. 코드의 중복을 줄일 수 있다.
2. 토드의 관리가 쉽다.
3. 코드를 재사용할 수 있다.
4. 코드가 간결해서 이해하기 쉬워진다.
// 중복코드제거, 관리 용이, 재사용가능

메서드의 작성
-> 반복적으로 수행되는 여러 문장을 메서도로 작성
-> 하나의 메서드는 한 가지 기능만 수행하도록 작성
// 코드 유지보수 , 최소한의 의미단위는 재사용성이 높아진다.


// 수업진행
메서드란?
-> 메서드 = 선언부 + 구현부
반환타입 메서드이름(타입 변수명, 타입변수명, ...)   // 선언부
{ //메서드 호출시 수행될 코드 }                         // 구현부

int add(int a, int b)                   // 선언부 
{int result = a+b; return result;}   // 구현부
return -> 작업결과가 여러개면? -> 배열이나 객체로 묶어서 주면 됨.


메서드의 구현부
-> 지역변수(lv) : 메서드 내에 선언된 변수


{ 메서드의 호출, 메서드의 실행흐름 }
메서드이름(값1, 값2, ...)   // 메서드를 호출하는 방법
-> 메서드 이름을 부르고, 실행 [작업에 필요한 값들] 을 시킨다.

1. print99danAll( );
2. int result = add( 3, 5 );
// 작업결과를 저장할 변수가 필요하여, int result이거 지정.
// 매개변수(메서드에서 호출한 쪽에서 준 값을 add메서드에 전달하고
                중간역활한다고 해서 영어로 파라미터라고 한다.)

//다시정리
메서드는 클래스영역에만 정의가능.

메서드의 실행흐름
1. main메서드에서 메서드add를 호출한다.
   인수 1L과 2L이 메서드 add의 매개변수 a,b에 각각 복사(대입)된다
2. 메서드 add의 괄호{ }안에 있는 문장들이 순서대로 수행된다.
3. 메서드 add의 모든 문장이 실행되거나 return문을 만나면,
    호출한 메서드(main메서드)로 되돌아와서 이후의 문장들을 실행한다.


{ return문 반환값 }
-> 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.
-> 작업이 시작하기 전의 끝난 경우과 작업을 진행할 수 없을 때, 
    중간할 수 있는 것을 return 문이라고 한다.
// 메서드가 작업을 마쳤을 때, 사용한다.

-> 반환 타입이 void가 아니므로 생략불가
-> 조건식이 참일 때만 실행 된다.
    // 조건식이 참일 때와 거짓일때 return문을 작성을 해주자!!
    // 조건식이 참일 때, [return;] 을 사용하면 함수가 그냥 [종료]된다.


{ 호출 스택(call stack) }
-> 메서드 수행에 필요한 메모리가 제공되는 공간
-> 메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제
// 스택(stack) -> 밑이 막힌 상자.  위에 차곡차곡 쌓인다.

아래 있는 메서드가 위의 메서드를 호출한 것
맨 위의 메서드 하나만 실행 중, 나머지는 대기중


{ 기본형 매개변수 }
기본형 매개변수 -> 변수의 값을 일기만 할 수 있다. 
                          __ read only
--> static void change(int x)_값이 바뀌지 않아요!

{ 참조형 매개변수, 참조형 반환타입 }
참조형 매개변수 -> 변수의 값을 읽고 변경할 수 있다. 
                          __ read & write
--> static void change(Data2 d)_값이 바뀌네요!
// 복사한 객체의 주소를 반환한다 // 객체를 반환한다.
--> 참조 변수가 없는 이유
     1. 같은 class안에 있어서 그렇다.    
     2. static메서드이기 때문이다.

// 다시정리
static 메서드   -> 객체생성 없이 호출가능
인스턴스 변수 -> 객체 생성을 해야 호출이 가능

객체생성 -> Time e = new Time( );
객체호출 -> e.copy( );



[{ static메서드와 인스턴스 메서드 }]

인스턴스 메서드 -> static 없다.
     static 메서드 -> static 있다.

// 정리__인스턴스 메서드와 static메서드는 반대이다.!!
1. 인스턴스 메서드
-> 인스턴스 생성 후, '참조변수.메서드이름()'으로 호출
-> 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
-> 메서드 내에서 인스턴스 변수(iv) 사용가능

2. static메서드(클래스메서드)
-> 객체생성없이 '클래스 이름.메서드이름()'으로 호출
-> 인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드
     // iv, im 메서드 호출할 수 없음. __ 객체가 필요한 메서드
-> 메서드 내에서 인스턴스 변수(iv) 사용불가
-> 유효 범위가 블럭단위 입니다!!


// class MyMath2{ }를 생성하고,
   class MathTest2{
    public static void main(String arg[]){
        // 클래스 메서드 호출__객체 생성없이 호출가능!
                                    __ iv가 필요 없음.
        // 인스턴스 생성__ 객체 생성시 사용가능!
    }
}

// 클래스메서드 호출     __ 클래스이름.메서드이름( );
// 인스턴스메서드 호출  __    참조변수.메서드이름( );



{( static을 언제 붙여야 할까? )}
-> 속성(멤버 변수)중에서 공통 속성에 static을 붙인다.
-> 인스턴스 멤버(iv, im)을 사용하지 않는 메서드에 static을 붙인다.
-> static 메서드는 인스턴스 변수(iv)를 사용할 수 없다.
// iv를 안 쓰면 static메서드, iv을 쓰면 인스턴스 메서드
// cv는 언제나 사용가능,  iv는 객체생성 후 사용가능.
// 메서드는 명령문 집합!!

1. void는 인스턴스 변수           , 클래스 변수 사용가능.
2. static는 인스턴스 변수 불가능, 클래스 변수 사용가능.
  // static 메서드는 인스턴스메서드 호출만 안되요!!



Q. static 메서드는 static메서드 호출가능?
A. 네

Q. static 메서드는 인스턴스 변수 사용가능?
A. 아니요 __ iv는 객체를 생성해야 사용이 가능하다.
             __static메서드는 언지나 호출이 가능하다.

Q. static 메서드는 인스턴스 메서드 호출가능?
A. 아니요.    //iv는 객체 생성해야 사용이 가능하기 때문이다.

Q. 왜? static메서드는 인스턴스 멤버를 쓸 수 없나요?
A. static메서드 호출시 객체 (iv묶음) 가 없을 수도 있어서
--> 가능성을 열어두는 것인가???
// static메서드는 항상 호출,    // 인스턴스 멤버 -> iv, im


{ 오버로딩__(overloading) }
-> 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것
-> [ 메서드(n) : 메서드이름(1) = 1 : 1 ]

메서드 오버로딩이 성립하기 위한 조건
1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야 한다 
   (int a, int x)_타입이 같으면 오버로딩이 아닙니다!!
3. 반환 타입은 영향없다. (Ex> int, long)

예제 __ 매개변수는 다르지만 가은 의미의 기능수행

오버로딩의 종류
1. 메서드 오버로딩
2. 연산자 오버리딩 __ ( 부호, 덧셈, 문자열 결합 )












