{ 상속 }
상속( lnheritance )
-> 기본의 클래스로 새로운 클래스를 작성하는 것. (코드의 재사용)
-> 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
-> 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
-> 자손의 멤버 개수는 조상보다 적을 수 없다. (같거나 많다.)
-> 자손의 변경은 조상에 영향을 미치지 않는다.

class 자식클래스 extends 부모클래스{ // ... }

class Chid extends Parent {}
// Parent <--- Child


Ex> class Parent{ int age; }
      class Child extends Parent {
          System.out.println("놀자~"); // 새로운 멤버 추가
      }  // 자식 안에 부모가 있다???
// Child는 자신 멤버 + 상속받은 것 >= 조상클래스


상속을 받는 것과 안 받는 것의 대한 차이점
-> 결과적으로는 변화가 없다.
-> 보모클래스의 변화가 있으면, 자식클래스는 변화가 있다.


{ 클래스 간의 관계 상속과 포함 }
1. 포함관계
포함(composite)이란?
-> 클래스의 멤버로 참조변수를 선언하는 것.
-> 작은 단위의 클래스를 만들고, 이 들은 조합해서 클래스를 만든다.

class Circle {
    Point c = new Pont( );
    int r ;
}   // 저장공간은 차이가 없지만, 저장구조가 다르다.
       -> c . c . x ( 그리고 복잡도가 줄어든다? )


// 클래스의 관계 = 1. 상속 2. 포함
   상속관계 -> '~은 ~이다.(is-a)' 
   포함관계 -> '~은~을 가지고 있다. (has-a)' 

( 포함 )
class Circle{
    Point c =new Pont();
    int r;
}

( 상속 )
class Circle extends Point{
    int r;
}
// 프로그래밍 = 설계(90%) + 코딩(10%)



{ 단일 상속 Object클래스 }
단일 상속(Single lnheritance)
-> java는 단일상속만을 허용한다. (c++은 다중상속 허용)
// 단일상속 -- 하나의 부모만 상속
class TvDVD extneds Tv, DVD { // ... }  // 에러 조상은 하나만 허용.
-> 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속.
toString(), equals(Object obj), hashCode(), ...


//   비중이 높은 클래스 하나만 상속관계로,
     나머지는 포함관계로 한다.

class TvDVD extends TV {
    DVD dvd = newDVD( );
    // ... 객체사용란 ...
}   //다중상속의 효과를 불러올 수 있다.


Object클래스 - 모든 클래스의 조상
-> 부모가 없는 클래스는 자동적을 Object클래스를 상속받게 된다.
[ 자동추가_부모가 없을 때, 컴파일이 어떻게 바뀌나면 ]
  class Tv        extends Object{ //... }
  class SmartTv extends Tv{ //... }


상속계증도
( Object ) <-- ( Tv ) <-- ( smartTv )



{ 오버라이딩  오버로딩VS오버라이딩 }
메서드 오버라이딩(overriding)
-> 상속받은 조상의 메서드를 자신에 맞게 변경하는 것.

오버라이딩의 조건
1. {선언부}가 조상 클래스의 메서드와 일치해야 한다.
2. {접근 제어자}를 조상 클래스의 메서드보다 
   좁은 범위로 변경할 수 없다.
3. {예외}는 조상 클래스의 메서드보다 많이 선언할 수 없다.
// 선언부       (반환타입, 메서드이름, 매개변수목록) 
// 접근제어자 (public, protected, (default), private)
// 예외         (IoException, SQLException)

class Point{ 
    int x, y; 

    String getLocation(){  // 선언부 입니다!!
        return "x: " + x + ", y: " + y;
    }
}

class Point3D extends Point {
    int z;

    String getLocation(){
        return "x: " + x + ", y: " + y + ", z: " + z;
    }
}

오버로딩 VS 오버라이딩
오버로딩(overloading)
-> 기본에 없는 새로운 메서드를 정의하는 것(new)
오버라이딩(overriding)
-> {상속}받은 메서드의 내용을 {변경}하는 것(change, modify)


class Parent{
    void parentMethod() {}
}

class Child{
    void parentMethod(){}         // 오버라이딩
    void parentMethod(int i){}    // 오버로딩
   ->  메서드는 그대로 있는데, 매개변수가 다른 경우

    void childMethod(){}           // 메서드 정의
    void childMEthod(int i){}      // 오버로딩
    void childMethod(){}           // 중복정의
}



{ 참조변수 super  ,  생성자 super( ) }

참조변수 super
-> 객체 자신을 가리키는 참조변수. 
    __인스턴스 메서드(생성자)내에만 존재
-> 조상의 멤버를 자신의 멤버와 구별할 때, 사용
// static메서드 내에서 사용불가
// super는 조상멤버, 자신멤버로 구별할때, 쓰임.

예제 2
class Parent { int x = 10; }      // super.x

class Child extends Parent {    // this.x
    int x = 20;
}

예제 3
class Parent2 { int x = 10; }    // super.x와 this.x 둘다 가능!

class Child2 extends Parent2 {
    void method(){
        System.out.println("x= " + x);
        System.out.println("this.x= " + this.x);
        system.out.println("super.x= " + super.x);
    }
}


super( ) __ 조상과 생성자
-> 조상의 생성자를 호출할 때 사용
-> 조상의 멤버는 조상의 생성자를 호출해서 초기화
{추가조건}
-> 생성자의 첫 불에 반드시 생성자를 호출해야 한다.
-> 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입
// 모든 생성자는 첫불에 다른 생성자를 호출한다.

class Point { 
    int x, y; 

    Point( int x, int y){
        this.x = x;
        this.y - y;
    }
}

class Point3D extends Point{
    int z;

    Point3D(int x, int y, int z){
        super(x, y);   // 조상클래스의 생성자 Point(int x, int y)를 호출
        this.z = z;    // 자신의 멤버를 초기화
    }
}



{ 패키지,  클래스 패스 }
패키지(package) 
-> 서로 관련된 클래스의 묶음 __ java8기분 약 4000클래스
-> 클래스는 클래스파일(*.class),
    패키지는 폴더.   ,  하위 패키지는 하위 폴더.
-> 클래스의 실제 이름(full name)은 패키지를 포함(java.lang.String)
    rt.jar는 클래스들을 압축한 파일(JDK설치경로\jre\lib에 위치)
// rt.jar -> runtime실행할때, 실행중
// jar은 (클래스 파일 묶어놓은 것)
--> java9부터 rt.jar 개념 사라짐  
이유 : java9부터 module개념 등장 -> rt.jar는 크다, 작은걸로 쪼개짐. 


패키지의 선언
-> 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
-> 같은 소스파일의 클래스들은 모두 같은 패키지에 속하게 된다.
-> 패키지 선언이 없으면 이름없는(unnamed)패키지에 속하게 된다.
// unnamed -> default package

클래스 패스(classpath)
-> 클래스 파일(*.class)의 위치를 알려주는 경로(path)
-> 환경변수 classpath로 관리하며, 경로간의 구분자는 ';'를 사용
-> classpath(환경변수)에 패키지의 루트를 등록해줘야 함.



{ import 문  ,  static import 문 }
import 문
-> 클래스를 사용할 때 패키지이름을 생략할 수 있다.
-> 컴파일러에게 클래스가 속한 패키지를 알려준다.
-> java.lang패키지의 클래스는 import하지 않고도 사용할 수 있다.
    String, Object, System, Thread ...

class ImportTest{
    java.util.Date today = new java.util.Date( );
}

import java.util.Date;
class ImportTest{
    Date today = new Date( );
}


import문의 선언
-> import문을 선언하는 방법은 다음과 같다.
import 패키지명.클래스명;     // "ctrl + shift + o"
OR
import 패키지명.*;
-> import문은 패키지문과 클래스선언의 사이에 선언한다.
// {패키지} 다음 {import문} 다음 {클래스}

--> import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음.
--> 다음의 두 코드는 서로 의미가 다르다.
--> 이름이 같은 클래스가 속한 두 패키지를 import할 때는
      클래스 앞에 패키지명을 붙여줘야 한다.


static import문
-> static멤버를 사용할 때, 클래스 이름을 생략할 수 있게 해준다.
import static java.lang.Integer.*;      [* =모든 static멤버(변수, 메서드)] 
  // Integer클래스의 모든 static메서드
import static java.lang.Math.random;   
  // Math.random()만. 괄호 안붙임.
import static java.lang.System.out;     
 // System.out을 out만으로 참조가능.  [out == static변수]

// System.out.println(Math.random());
    <-> out.println(random());            이렇게 사용가능!!



{ 제어자 static, final, abstract }
제어자(modifier)
-> 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여

1. 접근 제어자
-> public, protected, (default), private
2. 그외
-> static, final, abstract, native, transient, 
    synchronized, volatile, strictfp


-> 하나의 대상에 여러 제아자를 가이 사용가능(접근 제어자는 하나만)
public class ModifierTest{
    public static final int WIDTH = 200;

    public static void main(String[] args){
        System.out.println("WIDTH="+WIDTH);
    }
}

// public static final = 접근제어자 + 그 외 + 그 외



static __ 클래스의, 공통적인

static 
1. 대상
-- 멤버변수
--> 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
--> 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
--> 클래스가 메모리에 로드될 때 생성된다.
-- 메서드
--> 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
--> static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.


final __ 마지막의, 변경될 수 없는

final
1. 대상
-- 클래스
--> 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
      그레서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
-- 메서드
--> 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을
      통해 재정의 될 수 없다,
-- 멤버변수, 지역변수
--> 변수 앞에 final이 붙으면, 값을 변경할수 없는 상수가 된다.

final class FinalTest{               // 조상이 될 수 없는 클래스
    final int MAX_SIZE = 10;     // 값을 변경할 수 없는 멤버변수(상수)

    final void getMaxSize(){      // 오버라이딩할 수 없는 메서드(변경불가)
        final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수)
        return MAX_SIZE;
    }
}


abstract __ 추상의, 미완성의

abstract
1. 대상
-- 클래스
--> 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
-- 메서드
--> 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을
     알린다.

abstract class AbstractTest{   // 추상클래스(추상 메서드를 포함한 클래스)
    abstract void move( );      // 추상메서드(구현부가 없는 메서드)
} //미완성클래스

미완성클래스 -> 제품생성 불가
AbstractTest a = new AbstractTest( ); 
// error,  추상클래스의 인스턴스 생성불가..

추상클래스가 객체를 생성하는 방법
-> 추상클래스를 상속을 통해서 완전한 클래스를 만들 후에 
    객체생성가능
// 완성된 설계도 -> 구상,구체 클래스


{ 접근 제어자 }
접근 제어자(access modifier)
1. private      -> 같은 클래스 내에서만 접근이 가능하다.
2. (default)    -> 같은 패키지 내에서만 접근이 가능하다.
3. protected  -> 같은 패키지 내에서.  AND 
                      다른 패키지의 자손클래스에서 접근이 가능하다.
4. public       -> 접근 제한이 전혀 없다.


제어자         같은 클래스       같은 패키지      자손클래스       전체
public                O                   O                   O               O
protected           O                    O                   O 
(default)              O                   O
private               O


접근제한없음      같은패키지+자손       같은패키지      같은 클래스
public            >    protected          >    (default)    >    private



{ 캡슐화 }
캡슐화와 접근 제어자

접근 제어자를 사용하는 이유
-> 외부로부터 데이터를 보호하기 위해서
-> 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서



{다형성(polymorphism)}
-> 여러 가지 형태를 가질 수 있는 능력
-> 조상 타입 참조 변수로 자손 타입 객체를 다루는 것
// 하나가 여러가지 형태를 가질 수있다.

// Tv t = new SmartTv( ); --> 타입 불일치 가 OK?? //

class Tv {
    boolean power;
    int channel;

    void power( ) {power = !=power;}
    void channelUp( ) {++channel;}
    void channelDown( ) {--channel;}
}

class smartTv extends Tv{
    String text;
    void caption( ) { }
}

-> 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이?
SmartTv s = new SmartTv( );  
//--> 참조 변수와 인스턴스의 타입이 일치
Tv         t = new SmartTv( );  
//--> 조상 타입 참조변수로 자손 타입 인스턴스 참조
--> Tv t == 조상 타입의 참조변수


다형성(polymorphism)
-> 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
Tv         t = new SmartTv();   // OK.   허용
SmartTv s = new Tv();           // error 허용 안됨.


Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?
A. 아닙니다. 일치하는 것이 보통이지만, 일치하지 않을 수도 있습니다

Q.참조변수가 조상타입일 때와 자손타입일 때의 차이?
A. 참조변수로 사용할 수 있는 멤버의 갯수가 달라집니다.

Q.자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 있나요?
A. 아니요. 허용되지 않습니다.
// 조상이 5개 < 자손7개 허용  ,  조상이7개 < 자손5개 허용 안됨!!







