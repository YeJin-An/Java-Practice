ch6-39  
{ 인터페이스의 장점(1) }
-> 두 대상(객체)간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 한다.
interface = inter(~사이) + face(대상)
--> 어떤 두 대상 사이에 '중간 역할'


//인터페이스의 장점
1. 두 대상(객체)간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 한다.
2. 선언(설계)와 구현을 분리시킬 수 있게 한다.
   -> 껍데기와 알멍이를 분리시킬 수 있게 한다.
3. 인터페이스 덕분에 B가 변경되어도 A는 안바꿀 수 있다.
    (느슨한 결합)

class B{
    public void method(){
        System.out.println("methodInB");
    }
}

interface I {
    public void method();
}

class B implements I {
    public void method(){
        System.out.println("methodInB");
    }
}
// 인터페이스 새로 정의 및 구현하는 것.


class A {public void method(B b){b.method();}}
// 인터페이스 B를 구현한 넘들만 들어와라!!

interface I {public void method();}            //method()의 선언
class B implements I 
{public void method()
{System.out.println("B클래스의 메서드")}}   //method()의 구현

public class InterfaceTest{
    public static void main(String[] args){
        A a = new A();
        a.method(newC());    // A가 C를 사용(의존)
    }
}


// 껍데기(추상메서드 집합) , 추상메서드 호출가능.
{ 인터페이스의 장점(2) }
-> 개발 시간을 단축할 수 있다.
-> 변경에 유리한 유연난 설계가 가능하다.
-> 표준화가 가능하다.
    // JDBC == 인터페이스 집합!!
-> 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.
Ex> 인터페이스 구현!!???
interface Repairable(){}
class SCV extends GroundUnit implements Repairable{}
class Tank extends GroundUnit implements Repairable{}
class Dropship extends AirUnit implements Repairable{}
// 자손이 아닌 {관계없는 클래스들을 관계에 맺어줄 수 있다.}


오버로딩이란?
같은 이름 메서드 = void repair(Tank t){}, void repair(Dropship d){}
다형성, 추상화, 인터페이스  // 매우매우 중요합니다!!!!

인터페이스이란?
추상 메서드의 집합니다.

{ 디폴트 메서드와 static메서드 }
-> 인터페이스에 디폴트 메서드, static메서드 추가가능.
     // JDK1.8부터__ 원래는 인터페이스 추상메서도만 가질 수 있었다.

-> 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움.
    해결책 => 디폴트 메서드(default method)

-> 디폴트 메서드는 인스턴스 메서드(인터페이스 원칙 위반)
interface MyInterface{
    void method();
    default void newMethod(){}
}  //인터페이스 윈칙 위반__예외사항 입니다!

-> 디폴트 메서드가 메서드가 기존의 메서드와 충돌할 때의 해결책
1) 여러 인터페이스의 디폴트 메서드 간의 충돌
    -- 인터페이스를 구현한 클래스에서 디폴트 메서드를 
       오버라이딩 해야 한다.
2) 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    -- 조상 클래스의 메서드가 상속되고, 디폴트는 무시된다.



ㅇㅇㅇㅇㅇㅇㅇ











